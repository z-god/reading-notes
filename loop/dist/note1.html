<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>2 Node简介 - Documents</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="assets/css/bulma.min.css"><link rel="stylesheet" href="assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="index.html">Documents</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="note1.html" class="breadcrumb-item">2 Node简介</a></div><h1 class="article-title">2 Node简介</h1><div class="article"><p>进行I/O操作阻塞式编程模型：I/O操作和本地函数调用的处理过程中，需要一直等待知道某个操作结束才能继续下去。</p><p>多线程编程模型：线程可以看作为一种轻量级进程，与同一进程的线程共享内存。当一个线程等待I/O操作时，另一个线程就可以接管CPU，等待线程I/O操作结束被唤醒。线程执行期间可以被中断，之后还能够恢复执行。</p><h2 id="21事件驱动编程风格介绍">2.1事件驱动编程风格介绍 <a class="markdownIt-Anchor" href="#21事件驱动编程风格介绍">#</a></h2><blockquote><p>什么是事件驱动变成风格？这种风格有什么优点？</p></blockquote><p>事件驱动编程：程序的执行流程取决于事件，事件由事件处理程序或者事件回调函数进行处理。</p><p>定义感兴趣事件发生时由系统调用的函数来取代应用返回值得编程风格。多个I/O可以并行进行，每个操作结束时会分别调用对应的回调函数。</p><p>事件循环：一个处于不间断循环的结构，在一个进程中运行的单个线程。<strong>功能</strong>：事件检测和事件触发处理。<strong>特点</strong>：1.在任一给定的时刻，最多运行一个事件处理程序。2.事件处理程序可以不间断运行直到结束。</p><h2 id="22node和javascript如何简化异步应用程序的编写">2.2Node和JavaScript如何简化异步应用程序的编写 <a class="markdownIt-Anchor" href="#22node和javascript如何简化异步应用程序的编写">#</a></h2><blockquote><p>JavaScript具有闭包和第一类函数，这使得它非常适合于事件驱动编程。</p></blockquote><h3 id="221-什么是闭包">2.2.1 什么是闭包 <a class="markdownIt-Anchor" href="#221-什么是闭包">#</a></h3><p>闭包就是函数，但是它可以继承并访问它自身被声明的那个作用域的变量。</p><blockquote><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>将一个回调函数作为参数传递给另一个进行I/O操作的函数时，回调函数稍后会被调用，被调用时，回调函数会记住它自身声明时所在的上下文，并且可以访问该上下文及其父上下文的所有变量。</p><h3 id="222-闭包如何辅助异步编程">2.2.2 闭包如何辅助异步编程 <a class="markdownIt-Anchor" href="#222-闭包如何辅助异步编程">#</a></h3><p>可以通过将状态变量传递给函数而不必维护它就能进行事件驱动编程，JavaScript的闭包维护状态变量。</p><h2 id="23-小结">2.3 小结 <a class="markdownIt-Anchor" href="#23-小结">#</a></h2><ul><li><p>事件驱动编程是一种程序流程取决于事件发生的编程风格。</p></li><li><p>为感兴趣的事件注册回调函数作为事件处理的处理程序，事件发生时系统会调用处理程序。</p></li></ul></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="index.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="note2.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.14</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item chapter-item-current"><a href="note1.html">2 Node简介</a></li><li class="chapter-item"><a href="note2.html">Node核心API基础</a></li><li class="chapter-item"><a href="note3.html">4 应用缓冲区处理、编码和解码二进制数据</a></li><li class="chapter-item"><a href="note4.html">使用事件发射器简化事件绑定</a></li><li class="chapter-item"><a href="你不知道的JavaScript--读书笔记(1).html">《你不知道的javascript》（上）</a></li><li class="chapter-item"><a href="你不知道的JavaScript--读书笔记(2).html">词法作用域</a></li><li class="chapter-item"><a href="你不知道的JavaScript--读书笔记(5).html">作用域闭包</a></li><li class="chapter-item"><a href="你不知道的JavaScript--读书笔记(6).html">你不知道的JavaScript</a></li><li class="chapter-item"><a href="你不知道的JavaScript--读书笔记(7).html">this</a></li><li class="chapter-item"><a href="你不知道的javascript--读书笔记(3).html">函数作用域和块作用域</a></li><li class="chapter-item"><a href="你不知道的javascript--读书笔记(4).html">提升</a></li></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"note1.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#21%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E4%BB%8B%E7%BB%8D">2.1事件驱动编程风格介绍</a></li>\n<li><a href="#22node%E5%92%8Cjavascript%E5%A6%82%E4%BD%95%E7%AE%80%E5%8C%96%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99">2.2Node和JavaScript如何简化异步应用程序的编写</a>\n<ul>\n<li><a href="#221-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85">2.2.1 什么是闭包</a></li>\n<li><a href="#222-%E9%97%AD%E5%8C%85%E5%A6%82%E4%BD%95%E8%BE%85%E5%8A%A9%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">2.2.2 闭包如何辅助异步编程</a></li>\n</ul>\n</li>\n<li><a href="#23-%E5%B0%8F%E7%BB%93">2.3 小结</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script></body></html>