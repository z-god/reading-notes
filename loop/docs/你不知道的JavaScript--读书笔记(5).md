# 作用域闭包

> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

```javascript
function foo() {
  var a = 2;
    function bar() {
        console.log( a );
    }
    return bar;
  }
var baz = foo();
baz(); // 2
```

由于bar() 所声明的位置，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar()在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。**该引用(闭包) = bar() + bar所能访问到的自由变量**

> **闭包 = 函数 + 函数能够访问的自由变量**

## 循环和闭包

```javascript
for (var i=1; i<=5; i++) {
  setTimeout( function timer() {
        console.log( i );
    }, i*1000 );
}
```

延迟函数的回调会在循环结束时才执行，所以每次会输出一个6。

```javascript
for (var i=1; i<=5; i++) {
  (function(j) {
    setTimeout( function timer() {
        console.log( j );
    }, j*1000 );
    })( i );
}
//每隔一秒分别输出1,2,3,4,5
```

在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。

```javascript
for (let i=1; i<=5; i++) {
  setTimeout( function timer() {
    console.log( i );
  }, i*1000 );
}
//每隔一秒分别输出1,2,3,4,5
```

let 声明将变量i绑定在了for循环块作用域中，每次迭代都会声明，所以每次迭代都会是使用上一个迭代结束时的初始值来初始化变量i。

## 模块

模块模式需要具备两个必要条件：

1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。

2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

## 小结

+ 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。

+ 闭包 = 函数 + 函数能够访问的自由变量

+ （1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。