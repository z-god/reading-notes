<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>词法作用域 - 读书笔记</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">读书笔记</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../你不知道的JavaScript/index.html" class="breadcrumb-item">你不知道的JavaScript</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../你不知道的JavaScript/2.词法作用域.html" class="breadcrumb-item">词法作用域</a></div><h1 class="article-title">词法作用域</h1><div class="article"><blockquote><p>将“作用域&quot;定义为一套规则，用来管理引擎如何在当前作用于以及嵌套作用域中根据标识符名称进行变量查找。</p></blockquote><p>作用域有两种主要的工作模型，词法作用域和动态作用域。</p><h2 id="词法阶段">词法阶段 <a class="markdownIt-Anchor" href="#词法阶段">#</a></h2><p>词法作用域就是定义在词法阶段的作用域，是由你在写代码时将变量和块作用域写在哪决定的。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>) </span>{
<span class="hljs-keyword">var</span> b = a * <span class="hljs-number">2</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">c</span>) </span>{
<span class="hljs-built_in">console</span>.log( a, b, c );
}
bar( b * <span class="hljs-number">3</span> );
}
foo( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2, 4, 12</span>
引擎执行<span class="hljs-built_in">console</span>.log(...),从内部作用域bar(...)开始查找。引擎无法再其中找到a，就回去上一级嵌套的foo(...)作用域继续查找，在其中找到了a。
</code></pre><ul><li><strong>遮蔽效应：作用域查找会在找到第一个匹配的标识符时停止</strong></li></ul><p>作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见<br>第一个匹配的标识符为止。</p><p>全局变量会自动变为全局对象的属性，可以间接通过全局对象属性的引用来访问全局变量，这种方法可以访问被同名变量所遮蔽的全局变量，<strong>非全局变量被遮蔽，无法被访问到</strong></p><blockquote><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p></blockquote><h2 id="欺骗词法">欺骗词法 <a class="markdownIt-Anchor" href="#欺骗词法">#</a></h2><h3 id="eval">eval <a class="markdownIt-Anchor" href="#eval">#</a></h3><ul><li>eval(...) 接受一个字符串为参数。</li></ul><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">str, a</span>) </span>{
<span class="hljs-built_in">eval</span>( str ); <span class="hljs-comment">// 欺骗！</span>
<span class="hljs-built_in">console</span>.log( a, b );
}
<span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;
foo( <span class="hljs-string">"var b = 3;"</span>, <span class="hljs-number">1</span> ); <span class="hljs-comment">// 1, 3</span>

<span class="hljs-built_in">eval</span>(...)中传入字符串<span class="hljs-string">"var b = 3;"</span>这段代码会被当做本来就是在那里一样来处理，所以它对已经存在的foo(...)作用域进行了修改。

因此当<span class="hljs-built_in">console</span>.log(...)被执行时，咋foo(...)作用域中就已经找到a和b了，而外部作用域的b被遮蔽，所以这里输出的是<span class="hljs-string">"1,3"</span>.
</code></pre><ul><li><p>eval(..) 通常被用来执行动态创建的代码，因为像例子中这样动态地执行一段固定字符所组成的代码，并没有比直接将代码写在那里更有好处。</p></li><li><p>在严格模式的程序中， eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域</p></li></ul><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">str</span>) </span>{
<span class="hljs-meta">"use strict"</span>;
<span class="hljs-built_in">eval</span>( str );
<span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// ReferenceError: a is not defned</span>
}
foo( <span class="hljs-string">"var a = 2"</span> );
</code></pre><h3 id="with">with <a class="markdownIt-Anchor" href="#with">#</a></h3><p>with通常被当做引用同一个对象中的多个属性的快捷方式，不需要重复引用对象本身。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">with</span>(obj) {
        a = <span class="hljs-number">2</span>;
    }
}
<span class="hljs-keyword">var</span> o1 = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>
};
<span class="hljs-keyword">var</span> o2 = {
    <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>
};
foo(o1);
<span class="hljs-built_in">console</span>.log(o1.a);<span class="hljs-comment">//2</span>
foo(o2);
<span class="hljs-built_in">console</span>.log(o2.a);<span class="hljs-comment">//undefined</span>
<span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">//2</span>
</code></pre><figure><img src="http://upcxyyz.cn/test.png" alt="测试输出"><figcaption>测试输出</figcaption></figure><p>a = 2 赋值操作创建了一个全局的变量 a</p><blockquote><p>原因：with可以将对象处理为完全隔离的词法作用域，所以该对象的属性会被处理为定义在此作用域的词法标识符。<strong>with块内部正常的var声明不会被限制在with块的作用域中，而会被添加到with所在的函数作用域中</strong></p></blockquote><p>不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响（限制）。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval(..) 也被禁止了。</p><h3 id="性能">性能 <a class="markdownIt-Anchor" href="#性能">#</a></h3><p>eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词<br>法作用域。</p><p>如果代码中出现了大量的eval(...)或with，引擎无法准确找到标识符的位置，只能简单地假设关于标识符位置的判断都是无效的，以为引擎无法再词法分析阶段明确知道eval(...)会接收到什么代码，会对作用域进行什么样的修改，也无法知道with创建新此法作用域对象的内容到底是什么。词法阶段引擎所做的优化可能就毫无意义。最简单的做法就是完全不做任何优化，那么如果程序中有大量的eval(..)和with，那么运行起来一定会变得非常慢。</p><h2 id="小结">小结 <a class="markdownIt-Anchor" href="#小结">#</a></h2><ul><li><p><strong>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的</strong></p></li><li><p>词法分析阶段基本可以知道全部的标识符的位置以及如何声明，从而能够预测在执行过程中如何对其进行查找。</p></li><li><p>JavaScript两个机制“欺骗”词法作用域：eval(...)和with。</p></li><li><p>非严格模式下，在运行时，eval(...)对一段包含声明的“代码”字符串进行演算，借此修改已经存在的作用域。同样with通过讲一个对象引用当作作用域来处理，把对象的属性当作作用域标识符，从而创建一个新的词法作用域。</p></li><li><p>两个机制副作用是引擎在编译时对作用域查找进行优化。</p></li></ul></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../你不知道的JavaScript/1.作用域和闭包.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../你不知道的JavaScript/3.函数作用域和块作用域.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.14</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../node.js高级编程/index.html">node.js高级编程</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../node.js高级编程/1.Node简介.html">Node简介</a></li><li class="chapter-item"><a href="../node.js高级编程/2.Node核心API基础.html">Node核心API基础</a></li><li class="chapter-item"><a href="../node.js高级编程/3.应用缓冲区处理、编码和解码二进制数据.html">应用缓冲区处理、编码和解码二进制数据</a></li><li class="chapter-item"><a href="../node.js高级编程/4.使用事件发射器简化事件绑定.html">使用事件发射器简化事件绑定</a></li><li class="chapter-item"><a href="../node.js高级编程/5.查询和读写文件.html">查询和读写文件</a></li></ul><li class="chapter-item"><a href="../你不知道的JavaScript/index.html">你不知道的JavaScript</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../你不知道的JavaScript/1.作用域和闭包.html">作用域和闭包</a></li><li class="chapter-item chapter-item-current"><a href="../你不知道的JavaScript/2.词法作用域.html">词法作用域</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/3.函数作用域和块作用域.html">函数作用域和块作用域</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/4.提升.html">提升</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/5.作用域闭包.html">作用域闭包</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/6.作用域补充.html">作用域补充</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/7.关于this.html">关于this</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/8.this全面解析.html">this全面解析</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/9.对象.html">对象</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/91.原型.html">原型</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"你不知道的JavaScript/2.词法作用域.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E8%AF%8D%E6%B3%95%E9%98%B6%E6%AE%B5">词法阶段</a></li>\n<li><a href="#%E6%AC%BA%E9%AA%97%E8%AF%8D%E6%B3%95">欺骗词法</a>\n<ul>\n<li><a href="#eval">eval</a></li>\n<li><a href="#with">with</a></li>\n<li><a href="#%E6%80%A7%E8%83%BD">性能</a></li>\n</ul>\n</li>\n<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>