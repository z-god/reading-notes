<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>this全面解析 - Documents</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">Documents</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../你不知道的JavaScript/index.html" class="breadcrumb-item">你不知道的JavaScript</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../你不知道的JavaScript/8.this全面解析.html" class="breadcrumb-item">this全面解析</a></div><h1 class="article-title">this全面解析</h1><div class="article"><blockquote><p>每个函数的this是在调用时被绑定的，完全取决于函数的调用位置。</p></blockquote><h2 id="调用位置">调用位置 <a class="markdownIt-Anchor" href="#调用位置">#</a></h2><p>调用位置就是函数在代码中被调用的位置，而不是声明的位置。</p><p>最重要的是分析调用栈。<strong>调用栈：为了到达当前执行位置所调用的所有函数</strong>(可将其想象成函数调用链)</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 当前调用栈是： baz</span>
    <span class="hljs-comment">// 因此，当前调用位置是全局作用域</span>
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"baz"</span> );
    bar(); <span class="hljs-comment">// &lt;-- bar 的调用位置</span>
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar</span>
    <span class="hljs-comment">// 因此，当前调用位置在 baz 中</span>
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"bar"</span> );
    foo(); <span class="hljs-comment">// &lt;-- foo 的调用位置</span>
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar -&gt; foo</span>
    <span class="hljs-comment">// 因此，当前调用位置在 bar 中</span>
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"foo"</span> );
    }
baz(); <span class="hljs-comment">// &lt;-- baz 的调用位置</span>
</code></pre><h2 id="绑定规则">绑定规则 <a class="markdownIt-Anchor" href="#绑定规则">#</a></h2><h3 id="默认绑定">默认绑定 <a class="markdownIt-Anchor" href="#默认绑定">#</a></h3><blockquote><p>无法应用其他规则时的默认规则。</p></blockquote><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)
}

<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
foo();<span class="hljs-comment">//1</span>
</code></pre><p>调用foo()时，应用了this的默认绑定，因此this指向全局对象。foo()是直接使用不带任何修饰的函数引用进行调用，所以只能使用默认绑定，无法应用其他规则。</p><blockquote><p>严格模式，全局对象无法使用默认绑定。</p></blockquote><h3 id="隐式绑定">隐式绑定 <a class="markdownIt-Anchor" href="#隐式绑定">#</a></h3><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)
}

<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">a</span>:<span class="hljs-number">2</span>,
    <span class="hljs-attr">foo</span>: fpp
}
obj.foo();<span class="hljs-comment">//2</span>
</code></pre><p>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。对象属性引用链中只有最顶层或则说最后一层会影响调用位置。</p><h4 id="隐式丢失">隐式丢失 <a class="markdownIt-Anchor" href="#隐式丢失">#</a></h4><p>函数别名调用，参数传递（隐式赋值），回调函数都会丢失this绑定。被隐式绑定的函数丢失绑定对象，会应用默认绑定。</p><h3 id="显式绑定">显式绑定 <a class="markdownIt-Anchor" href="#显式绑定">#</a></h3><blockquote><p>call(...),apply(...)方法，第一个参数是一个对象，它们会把这个对象绑定定到this，接着在调用函数时指定这个this。</p></blockquote><pre class="hljs"><code>funcyion foo(){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)
}

<span class="hljs-keyword">var</span> obj = {
    a = <span class="hljs-number">2</span>
}
foo.call(obj);<span class="hljs-comment">//2</span>
</code></pre><p>解决丢失绑定方法：</p><ul><li><p>硬绑定</p></li><li><p>API调用的“上下文”</p></li></ul><h3 id="new绑定">new绑定 <a class="markdownIt-Anchor" href="#new绑定">#</a></h3><p>在JavaScript中，构造函数只是使用new操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。只是被new操作符调用的普通函数。</p><p>发生构造函数调用时：</p><ul><li><p>创建一个全新的对象。</p></li><li><p>该对象会被执行【原型】连接。</p></li><li><p>该对象会绑定到函数调用的this。</p></li><li><p>若函数未返回其它对象，那么new表达式中的函数会自动返回这个新对象。</p></li></ul><h2 id="判断this">判断this <a class="markdownIt-Anchor" href="#判断this">#</a></h2><ul><li><p>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。var bar = new foo()</p></li><li><p>函数是否通过 call、 apply（显式绑定）或者硬绑定调用？如果是的话， this 绑定的是指定的对象。var bar = foo.call(obj2)</p></li><li><p>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话， this 绑定的是那个上下文对象。var bar = obj1.foo()</p></li><li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。var bar = foo()</p></li></ul><h2 id="绑定例外">绑定例外 <a class="markdownIt-Anchor" href="#绑定例外">#</a></h2><h3 id="被忽略的this">被忽略的this <a class="markdownIt-Anchor" href="#被忽略的this">#</a></h3><p>把null或者undefined作为this的绑定对象传入call，apply或者bind，这些值在调用时会被忽略，实际应用默认绑定规则。</p><h3 id="间接引用">间接引用 <a class="markdownIt-Anchor" href="#间接引用">#</a></h3><p>创建一个函数的“间接引用”，调用该函数时会应用默认绑定。</p><h3 id="软绑定">软绑定 <a class="markdownIt-Anchor" href="#软绑定">#</a></h3><p>对指定的函数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把指定的默认对象 obj 绑定到 this，否则不会修改 this。</p><h2 id="小结">小结 <a class="markdownIt-Anchor" href="#小结">#</a></h2><ul><li><p>this判断：1.由 new 调用？绑定到新创建的对象。2.由 call 或者 apply（或者 bind）调用？绑定到指定的对象。3.由上下文对象调用？绑定到那个上下文对象。4.默认：在严格模式下绑定undefined，否则绑定到全局对象。</p></li><li><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。</p></li></ul></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../你不知道的JavaScript/7.关于this.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../你不知道的JavaScript/9.对象.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.14</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../node.js高级编程/index.html">node.js高级编程</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../node.js高级编程/1.Node简介.html">Node简介</a></li><li class="chapter-item"><a href="../node.js高级编程/2.Node核心API基础.html">Node核心API基础</a></li><li class="chapter-item"><a href="../node.js高级编程/3.应用缓冲区处理、编码和解码二进制数据.html">应用缓冲区处理、编码和解码二进制数据</a></li><li class="chapter-item"><a href="../node.js高级编程/4.使用事件发射器简化事件绑定.html">使用事件发射器简化事件绑定</a></li><li class="chapter-item"><a href="../node.js高级编程/5.查询和读写文件.html">查询和读写文件</a></li></ul><li class="chapter-item"><a href="../你不知道的JavaScript/index.html">你不知道的JavaScript</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../你不知道的JavaScript/1.作用域和闭包.html">作用域和闭包</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/2.词法作用域.html">词法作用域</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/3.函数作用域和块作用域.html">函数作用域和块作用域</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/4.提升.html">提升</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/5.作用域闭包.html">作用域闭包</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/6.作用域补充.html">作用域补充</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/7.关于this.html">关于this</a></li><li class="chapter-item chapter-item-current"><a href="../你不知道的JavaScript/8.this全面解析.html">this全面解析</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/9.对象.html">对象</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/91.原型.html">原型</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"你不知道的JavaScript/8.this全面解析.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E8%B0%83%E7%94%A8%E4%BD%8D%E7%BD%AE">调用位置</a></li>\n<li><a href="#%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99">绑定规则</a>\n<ul>\n<li><a href="#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A">默认绑定</a></li>\n<li><a href="#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A">隐式绑定</a></li>\n<li><a href="#%E6%98%BE%E5%BC%8F%E7%BB%91%E5%AE%9A">显式绑定</a></li>\n<li><a href="#new%E7%BB%91%E5%AE%9A">new绑定</a></li>\n</ul>\n</li>\n<li><a href="#%E5%88%A4%E6%96%ADthis">判断this</a></li>\n<li><a href="#%E7%BB%91%E5%AE%9A%E4%BE%8B%E5%A4%96">绑定例外</a>\n<ul>\n<li><a href="#%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84this">被忽略的this</a></li>\n<li><a href="#%E9%97%B4%E6%8E%A5%E5%BC%95%E7%94%A8">间接引用</a></li>\n<li><a href="#%E8%BD%AF%E7%BB%91%E5%AE%9A">软绑定</a></li>\n</ul>\n</li>\n<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>