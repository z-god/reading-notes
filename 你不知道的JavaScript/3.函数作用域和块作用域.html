<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>函数作用域和块作用域 - 读书笔记</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">读书笔记</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../你不知道的JavaScript/index.html" class="breadcrumb-item">你不知道的JavaScript</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../你不知道的JavaScript/3.函数作用域和块作用域.html" class="breadcrumb-item">函数作用域和块作用域</a></div><h1 class="article-title">函数作用域和块作用域</h1><div class="article"><h2 id="函数中的作用域">函数中的作用域 <a class="markdownIt-Anchor" href="#函数中的作用域">#</a></h2><blockquote><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用，嵌套作用域中也可使用。</p></blockquote><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>)</span>{
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;
    <span class="hljs-comment">//....</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//...</span>
    }

    <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span>
}
</code></pre><p>全局作用于中包含了标识符foo，foo(...)作用域中包含了标识符a,b,c,bar。而标识符a,b,c,bar都附属于作用域foo(...)，所以无法从foo(...)外部进行访问。但是这些标识符可以在foo(...)内部进行访问，同样在bar(...)中也可以访问(前提bar(...)中无同名标识符)。</p><h2 id="隐藏内部实现">隐藏内部实现 <a class="markdownIt-Anchor" href="#隐藏内部实现">#</a></h2><p>从所写的代码挑选一个任意片段，用函数声明包装，就是把这些代码“隐藏”起来了，实际是创建了一个作用域。<strong>这段代码中的任何声明都会绑定到这个新创建的作用域中，而不是之前的作用域。</strong></p><blockquote><p>最小授权或最小暴露原则：在软件设计中，应该最小限度地暴露必要内容，而降其他内容都“隐藏”起来。</p></blockquote><h3 id="规避冲突">规避冲突 <a class="markdownIt-Anchor" href="#规避冲突">#</a></h3><p>“隐藏”作用域中的变量和函数可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但是用途却不一样，无意间可能会造成命名冲突，冲突会导致变量的值被意外覆盖。</p><h4 id="全局命名空间">全局命名空间 <a class="markdownIt-Anchor" href="#全局命名空间">#</a></h4><p>当程序引入第三方的库时，其内部私有函数或变量没有很好隐藏，就会容易引起冲突。</p><p>通常会在全局作用域这种声明一个独特的变量通常是对象，<strong>这个对象被用作库的命名空间</strong>。</p><p>而要暴露给外界的变量或函数，会成为该对象的属性。</p><h4 id="模块管理">模块管理 <a class="markdownIt-Anchor" href="#模块管理">#</a></h4><p>使用模块管理器规避冲突。</p><h2 id="函数作用域">函数作用域 <a class="markdownIt-Anchor" href="#函数作用域">#</a></h2><blockquote><p>如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p></blockquote><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// &lt;-- 添加这一行</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;
<span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// 3</span>
} <span class="hljs-comment">// &lt;-- 以及这一行</span>
foo(); <span class="hljs-comment">// &lt;-- 以及这一行</span>
<span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">//2</span>

声明具名函数foo(),foo这个名称会“污染”其所在的作用域。
并且还必须显式foo()调用才能运行。
</code></pre><p>解决办法：</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a=<span class="hljs-number">2</span>;
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-comment">// &lt;-- 添加这一行</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;
<span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// 3</span>
})(); <span class="hljs-comment">// &lt;-- 以及这一行</span>
<span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// 2</span>

以(<span class="hljs-function"><span class="hljs-keyword">function</span>... 开始，会被当作函数表达式来处理。
作为函数表达式，<span class="hljs-title">foo</span>中能在其内部被访问。
</span></code></pre><h3 id="匿名和具名">匿名和具名 <a class="markdownIt-Anchor" href="#匿名和具名">#</a></h3><p>函数表达式是可以匿名的，函数声明不可以省略函数名。</p><p>匿名函数缺点：</p><ul><li><p>匿名函数在栈追踪中不会显示有意义的函数名，调试很困难。</p></li><li><p>如果没用函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，(递归)。另一个函数需要引用自身，是在事件触发后事件监听器需要解绑自身。</p></li><li><p>匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的代码不言自明。</p></li></ul><h3 id="立即执行函数表达式">立即执行函数表达式 <a class="markdownIt-Anchor" href="#立即执行函数表达式">#</a></h3><p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个<br>( ) 可以立即执行这个函数，比如 <strong>(function foo(){ .. })()/(function(){ .. }())</strong>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IIFE</span>(<span class="hljs-params"> global </span>) </span>{
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;
    <span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// 3</span>
    <span class="hljs-built_in">console</span>.log( global.a ); <span class="hljs-comment">// 2</span>
})( <span class="hljs-built_in">window</span> );
    <span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// 2</span>

    可以从外部作用域传递任何东西。
</code></pre><h2 id="块作用域">块作用域 <a class="markdownIt-Anchor" href="#块作用域">#</a></h2><pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) {
<span class="hljs-built_in">console</span>.log( i );
}

i 被绑定在了外部作用域。
</code></pre><p>变量声明应该距离使用的地方越近越好，并最大限度本地化。</p><h3 id="with">with <a class="markdownIt-Anchor" href="#with">#</a></h3><p>块作用域的一个例子（块作用域的一种形式）</p><h3 id="trycatch">try/catch <a class="markdownIt-Anchor" href="#trycatch">#</a></h3><p>catch会创建一个块作用域。其中声明仅在catch内部有效。</p><h3 id="let">let <a class="markdownIt-Anchor" href="#let">#</a></h3><p>let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地了所在的块作用域。</p><pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) {
<span class="hljs-built_in">console</span>.log( i );
}
<span class="hljs-built_in">console</span>.log( i ); <span class="hljs-comment">// ReferenceError</span>
</code></pre><blockquote><p><strong>let 声明附属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域）</strong></p></blockquote><h3 id="const">const <a class="markdownIt-Anchor" href="#const">#</a></h3><p>同let可以用来创建块作用域变量，但其值是固定的。</p><h2 id="小结">小结 <a class="markdownIt-Anchor" href="#小结">#</a></h2><ul><li><p>函数是javascript中最常见的作用域单元。</p></li><li><p>函数不是唯一的作用域单元。块作用域指的变量和函数不尽可以属于所处的作用域，也可属于某个代码块。</p></li><li><p>try/catch catch分句中具有块作用域。（ES3开始）</p></li><li><p>ES6引入let关键字，用来在任意代码块声明变量。</p></li></ul></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../你不知道的JavaScript/2.词法作用域.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../你不知道的JavaScript/4.提升.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.14</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../node.js高级编程/index.html">node.js高级编程</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../node.js高级编程/1.Node简介.html">Node简介</a></li><li class="chapter-item"><a href="../node.js高级编程/2.Node核心API基础.html">Node核心API基础</a></li><li class="chapter-item"><a href="../node.js高级编程/3.应用缓冲区处理、编码和解码二进制数据.html">应用缓冲区处理、编码和解码二进制数据</a></li><li class="chapter-item"><a href="../node.js高级编程/4.使用事件发射器简化事件绑定.html">使用事件发射器简化事件绑定</a></li><li class="chapter-item"><a href="../node.js高级编程/5.查询和读写文件.html">查询和读写文件</a></li></ul><li class="chapter-item"><a href="../你不知道的JavaScript/index.html">你不知道的JavaScript</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../你不知道的JavaScript/1.作用域和闭包.html">作用域和闭包</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/2.词法作用域.html">词法作用域</a></li><li class="chapter-item chapter-item-current"><a href="../你不知道的JavaScript/3.函数作用域和块作用域.html">函数作用域和块作用域</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/4.提升.html">提升</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/5.作用域闭包.html">作用域闭包</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/6.作用域补充.html">作用域补充</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/7.关于this.html">关于this</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/8.this全面解析.html">this全面解析</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/9.对象.html">对象</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/91.原型.html">原型</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"你不知道的JavaScript/3.函数作用域和块作用域.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">函数中的作用域</a></li>\n<li><a href="#%E9%9A%90%E8%97%8F%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0">隐藏内部实现</a>\n<ul>\n<li><a href="#%E8%A7%84%E9%81%BF%E5%86%B2%E7%AA%81">规避冲突</a></li>\n</ul>\n</li>\n<li><a href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F">函数作用域</a>\n<ul>\n<li><a href="#%E5%8C%BF%E5%90%8D%E5%92%8C%E5%85%B7%E5%90%8D">匿名和具名</a></li>\n<li><a href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">立即执行函数表达式</a></li>\n</ul>\n</li>\n<li><a href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F">块作用域</a>\n<ul>\n<li><a href="#with">with</a></li>\n<li><a href="#trycatch">try/catch</a></li>\n<li><a href="#let">let</a></li>\n<li><a href="#const">const</a></li>\n</ul>\n</li>\n<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>