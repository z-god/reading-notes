<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>原型 - Documents</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">Documents</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../你不知道的JavaScript/index.html" class="breadcrumb-item">你不知道的JavaScript</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../你不知道的JavaScript/91.原型.html" class="breadcrumb-item">原型</a></div><h1 class="article-title">原型</h1><div class="article"><h2 id="prototype">[[ProtoType]] <a class="markdownIt-Anchor" href="#prototype">#</a></h2><blockquote><p>JavaScript中对象有一个特殊的[[Prototype]]内置属性，就是对其他对象的引用。</p></blockquote><p>for...in遍历对象时的原理和查找完整条[[Prototype]]链类似 ，任何可以通过原型链访问到的属性都会被枚举。使用in操作符检查属性在对象中是否存在时，同样也会查找整条原型链，无论属性是否可枚举。</p><h3 id="objectprototype">Object.prototype <a class="markdownIt-Anchor" href="#objectprototype">#</a></h3><p>所有普通的[[Prototype]]链都会指向内置的Object.prototype。</p><h3 id="属性设置和屏蔽">属性设置和屏蔽 <a class="markdownIt-Anchor" href="#属性设置和屏蔽">#</a></h3><pre class="hljs"><code>myObjet.foo = <span class="hljs-string">"newman"</span>;
</code></pre><p>foo不直接存在于myObject中而是在于原型链上层时的情况：</p><ul><li><p>如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性（参见第 3 章）并且没有被标记为（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。</p></li><li><p>如果在 [[Prototype]] 链上层存在 foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</p></li><li><p>如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter（参见第 3 章），那就一定会调用这个 setter。 foo 不会被添加到（或者说屏蔽于） myObject，也不会重新定义 foo 这个 setter。</p></li></ul><p>隐式屏蔽</p><pre class="hljs"><code><span class="hljs-keyword">var</span> protoObject = {
    <span class="hljs-attr">n</span>:<span class="hljs-number">1</span>
};

<span class="hljs-keyword">var</span> myObj = <span class="hljs-built_in">Object</span>.create(protoObject);

protoObject.a;<span class="hljs-comment">//2</span>
myObj.a;<span class="hljs-comment">//2</span>

protoObject.hasOwnProperty(<span class="hljs-string">"a"</span>);<span class="hljs-comment">//true</span>
myObj.hasOwnProperty(<span class="hljs-string">"a"</span>)<span class="hljs-comment">//false</span>

myObj.a++;<span class="hljs-comment">//隐式屏蔽</span>

protoObject.a;<span class="hljs-comment">//2</span>
myObj.a;<span class="hljs-comment">//3</span>
myObj.hasOwnProperty(<span class="hljs-string">"a"</span>)<span class="hljs-comment">//true</span>
</code></pre><p>myObj.a++ 相当于 myObj.a = myObj.a + 1,该操作会查找属性a（通过[[Prototype]]）,然后给其加1，再用[[Put]]将值赋值给myObj中新建的屏蔽属性a。</p><p>继承意味着复制操作，JavaScript并不会复制对象属性。相反，JavaScript会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。</p><h3 id="构造函数">“构造函数” <a class="markdownIt-Anchor" href="#构造函数">#</a></h3><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">//...</span>
}
Foo.prototype.constructor === Foo;<span class="hljs-comment">//true</span>

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Foo();
a.constructor === Foo;<span class="hljs-comment">//true</span>

.constructor引用被委托给了Foo.prototype，而Foo.prototype.constructor默认指向Foo。

a.constructor只是通过默认的[[Prototype]]委托指向Foo,这和<span class="hljs-string">"构造"</span>毫无关系。

Foo.constructor的.constructor属性只是Foo函数在声明时的默认属性。若创建了一个新对象并替换了函数默认的.prototype对象引用,新对象并不会自动获得.constructor属性。
</code></pre><p>函数不是构造函数，但是当且仅当使用new时，函数会变成“构造函数调用”。</p><p>两种把Bar.prototype关联到Foo.prototype的方法：</p><pre class="hljs"><code><span class="hljs-comment">// ES6 之前需要抛弃默认的 Bar.prototype</span>
Bar.ptototype = <span class="hljs-built_in">Object</span>.create( Foo.prototype );
<span class="hljs-comment">// ES6 开始可以直接修改现有的 Bar.prototype</span>
<span class="hljs-built_in">Object</span>.setPrototypeOf( Bar.prototype, Foo.prototype );
</code></pre><h2 id="对象关联">对象关联 <a class="markdownIt-Anchor" href="#对象关联">#</a></h2><p>[[Prototype]]机制就是存在域对象中的一个内部链，他会引用其他对象。**如果在对象上没有找到需要的属性或者方法引用，引擎就<br>会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。**</p><h3 id="objectcreate">Object.create(..) <a class="markdownIt-Anchor" href="#objectcreate">#</a></h3><pre class="hljs"><code><span class="hljs-keyword">var</span> foo = {
<span class="hljs-attr">something</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Tell me something good..."</span> );
}
};
<span class="hljs-keyword">var</span> bar = <span class="hljs-built_in">Object</span>.create( foo );
bar.something(); <span class="hljs-comment">// Tell me something good...</span>
</code></pre><p>Object.create(..)会创建一个新对象并把它关联到我们指定的对象。</p><h2 id="小结">小结 <a class="markdownIt-Anchor" href="#小结">#</a></h2><ul><li><p>访问对象中并不存在的属性,[[Get]]操作会查找对象内部[[Prototype]]关联的对象，此关联关系实际上定义了一条“原型链”,查找属性时会对它进行遍历。</p></li><li><p>所有普通对象都有内置的Object.prototype，指向原型链顶端，如果在原型链中找不到指定的属性就会停止。</p></li><li><p>关联两个对象常用方法是使用new关键词进行函数调用。</p></li><li><p>JavaScript不会进行复制(&quot;类继承&quot;)，对象之间是通过内部的[[prototype]]链的关联。</p></li><li><p>对象之间的关系不是复制而是委托。</p></li></ul></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../你不知道的JavaScript/9.对象.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link link-disabled"><span class="icon icon-next-disabled" data-icon="next-disabled"></span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.14</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../node.js高级编程/index.html">node.js高级编程</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../node.js高级编程/1.Node简介.html">Node简介</a></li><li class="chapter-item"><a href="../node.js高级编程/2.Node核心API基础.html">Node核心API基础</a></li><li class="chapter-item"><a href="../node.js高级编程/3.应用缓冲区处理、编码和解码二进制数据.html">应用缓冲区处理、编码和解码二进制数据</a></li><li class="chapter-item"><a href="../node.js高级编程/4.使用事件发射器简化事件绑定.html">使用事件发射器简化事件绑定</a></li><li class="chapter-item"><a href="../node.js高级编程/5.查询和读写文件.html">查询和读写文件</a></li></ul><li class="chapter-item"><a href="../你不知道的JavaScript/index.html">你不知道的JavaScript</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../你不知道的JavaScript/1.作用域和闭包.html">作用域和闭包</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/2.词法作用域.html">词法作用域</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/3.函数作用域和块作用域.html">函数作用域和块作用域</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/4.提升.html">提升</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/5.作用域闭包.html">作用域闭包</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/6.作用域补充.html">作用域补充</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/7.关于this.html">关于this</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/8.this全面解析.html">this全面解析</a></li><li class="chapter-item"><a href="../你不知道的JavaScript/9.对象.html">对象</a></li><li class="chapter-item chapter-item-current"><a href="../你不知道的JavaScript/91.原型.html">原型</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"你不知道的JavaScript/91.原型.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#prototype">[[ProtoType]]</a>\n<ul>\n<li><a href="#objectprototype">Object.prototype</a></li>\n<li><a href="#%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%B1%8F%E8%94%BD">属性设置和屏蔽</a></li>\n<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">“构造函数”</a></li>\n</ul>\n</li>\n<li><a href="#%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94">对象关联</a>\n<ul>\n<li><a href="#objectcreate">Object.create(..)</a></li>\n</ul>\n</li>\n<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>