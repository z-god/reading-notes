# 函数作用域和块作用域

## 函数中的作用域

> 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用，嵌套作用域中也可使用。

```javascript
function foo(a){
    var b = 2;
    //....
    function bar(){
        //...
    }

    var c = 3
}
```

全局作用于中包含了标识符foo，foo(...)作用域中包含了标识符a,b,c,bar。而标识符a,b,c,bar都附属于作用域foo(...)，所以无法从foo(...)外部进行访问。但是这些标识符可以在foo(...)内部进行访问，同样在bar(...)中也可以访问(前提bar(...)中无同名标识符)。

## 隐藏内部实现

从所写的代码挑选一个任意片段，用函数声明包装，就是把这些代码“隐藏”起来了，实际是创建了一个作用域。**这段代码中的任何声明都会绑定到这个新创建的作用域中，而不是之前的作用域。**

> 最小授权或最小暴露原则：在软件设计中，应该最小限度地暴露必要内容，而降其他内容都“隐藏”起来。

### 规避冲突

“隐藏”作用域中的变量和函数可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但是用途却不一样，无意间可能会造成命名冲突，冲突会导致变量的值被意外覆盖。

#### 全局命名空间

当程序引入第三方的库时，其内部私有函数或变量没有很好隐藏，就会容易引起冲突。

通常会在全局作用域这种声明一个独特的变量通常是对象，**这个对象被用作库的命名空间**。

而要暴露给外界的变量或函数，会成为该对象的属性。

#### 模块管理

使用模块管理器规避冲突。

## 函数作用域

> 如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

```javascript
var a = 2;
function foo() { // <-- 添加这一行
var a = 3;
console.log( a ); // 3
} // <-- 以及这一行
foo(); // <-- 以及这一行
console.log( a ); //2

声明具名函数foo(),foo这个名称会“污染”其所在的作用域。
并且还必须显式foo()调用才能运行。
```

解决办法：

```javascript
var a=2;
(function foo(){ // <-- 添加这一行
var a = 3;
console.log( a ); // 3
})(); // <-- 以及这一行
console.log( a ); // 2

以(function... 开始，会被当作函数表达式来处理。
作为函数表达式，foo中能在其内部被访问。
```

### 匿名和具名

函数表达式是可以匿名的，函数声明不可以省略函数名。

匿名函数缺点：

+ 匿名函数在栈追踪中不会显示有意义的函数名，调试很困难。

+ 如果没用函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，(递归)。另一个函数需要引用自身，是在事件触发后事件监听器需要解绑自身。

+ 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的代码不言自明。

### 立即执行函数表达式

由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个
( ) 可以立即执行这个函数，比如 **(function foo(){ .. })()/(function(){ .. }())**。

```javascript
var a = 2;
(function IIFE( global ) {
    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2
})( window );
    console.log( a ); // 2

    可以从外部作用域传递任何东西。
```

## 块作用域

```javascript
for (var i=0; i<10; i++) {
console.log( i );
}

i 被绑定在了外部作用域。
```

变量声明应该距离使用的地方越近越好，并最大限度本地化。

### with

块作用域的一个例子（块作用域的一种形式）

### try/catch

catch会创建一个块作用域。其中声明仅在catch内部有效。

### let

let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地了所在的块作用域。

```javascript
for (let i=0; i<10; i++) {
console.log( i );
}
console.log( i ); // ReferenceError
```

> **let 声明附属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域）**

### const

同let可以用来创建块作用域变量，但其值是固定的。

## 小结

+ 函数是javascript中最常见的作用域单元。

+ 函数不是唯一的作用域单元。块作用域指的变量和函数不尽可以属于所处的作用域，也可属于某个代码块。

+ try/catch catch分句中具有块作用域。（ES3开始）

+ ES6引入let关键字，用来在任意代码块声明变量。